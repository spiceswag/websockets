//! Operations on web sockets with custom future implementations.
//! This includes closing the websocket, and pinging the peer.

use futures::FutureExt;
use std::{
    convert::TryFrom,
    future::Future,
    pin::Pin,
    task::{Context, Poll},
};
use tokio::sync::oneshot;

use crate::{error::InvalidFrameReason, WebSocketError};

/// A futures that resolves as soon as a
/// pong message is received from the server.
///
/// Each pong future maps one-to-one with a ping frame sent
/// to the server, but not vice-versa, with respect to the ping sender.
///
/// The websocket spec states that servers peers may choose
/// to "aggregate" pong frames by only replying to the latest one.
/// Therefore, pong futures may resolve in waves,
/// which may produce a warped perception of the actual latency
/// between the websocket peers.
///
/// # Panics
///
/// Polling this future causes a panic if
/// the relevant websocket has been dropped or closed.
///
/// https://datatracker.ietf.org/doc/html/rfc6455#section-5.5.3
#[derive(Debug)]
pub struct Pong {
    pub(super) recv: oneshot::Receiver<Option<Vec<u8>>>,
}

impl Future for Pong {
    type Output = Option<Vec<u8>>;

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        self.recv
            .poll_unpin(cx)
            .map(|res| res.expect("Pong future polled after the relevant websocket is closed"))
    }
}

/// A future that resolves when the remote peer acknowledges
/// a `Close` frame or drops its send half of the socket.
///
/// # Data Loss
///
/// Data frames received while waiting for the close acknowledgement
/// packet from the server will be lost.
///
/// If this is unacceptable, opt for TODO
///
/// https://datatracker.ietf.org/doc/html/rfc6455#section-7
#[derive(Debug)]
pub struct Close<'a> {
    todo: std::marker::PhantomData<&'a ()>,
}

/// The body of a close frame, consisting of a status code
/// hinting at the reason why the connection is being closed,
/// and a reason message meant to be read by the developers of
/// the application communicating.
///
/// https://datatracker.ietf.org/doc/html/rfc6455#section-5.5.1
#[derive(Debug)]
pub struct ClosePayload {
    /// The closing status for this payload.
    pub status: Status,
    /// Reason given for closing the connection.
    pub reason: Option<String>,
}

/// Status codes observable during the closing of a WebSocket connection.
///
/// This enum has been idiot-proofed, for the lack of a better term.
///
/// That means you can not use this enum in combination with any other API of this crate
/// to cause an active WebSocket connection to enter an invalid state.
#[derive(Debug)]
pub enum Status {
    /// The purpose of the websocket has been fulfilled.
    ///
    /// WebSocket status code 1000
    Ok,

    /// An endpoint is leaving the connection,
    /// such as a browser navigating away or a web server shutting down.
    ///
    /// WebSocket status code 1001
    GoingAway,

    /// An endpoint is terminating the connection due to a protocol error.
    ///
    /// WebSocket status code 1002
    ProtocolError,

    /// An endpoint has received data of a type it doesn't understand.
    ///
    /// WebSocket status code 1003
    UnacceptableData,

    // 1004 reserved
    /// No actual status code is present.
    ///
    /// # Oddities
    ///
    /// This status code is never sent by a peer, but is generated instead
    /// from the `websockets` library itself, as per spec, to indicate
    /// what's on the label.
    ///
    /// This status code can not be sent manually.
    ///
    /// WebSocket status code 1005
    MissingStatusCode,

    /// Indicates that the connection was shut down abnormally,
    /// for example, if no `Close` frames were exchanged
    ///
    /// This status code may not be sent by a peer but instead,
    /// generated by the `websockets` library when the peer did not
    /// reply with a `Close` frame of their own during shutdown.
    ///
    /// This status code can not be sent manually.
    ///
    /// WebSocket status code 1006
    AbnormalShutdown,

    /// An endpoint received data that was inconsistent with the
    /// type of the message.
    ///
    /// WebSocket status code 1007
    InvalidData,

    /// An endpoint has received data within a message that violates its policy.
    ///
    /// WebSocket status code 1008
    PolicyViolation,

    /// An endpoint has received a message that was too big.
    ///
    /// WebSocket status code 1009
    MessageTooLarge,

    /// The client is terminating the connection because it
    /// expected the server to negotiate one or more extensions, but the server didn't.
    ///
    /// The list of extensions that are needed should appear in the `reason` part of the Close frame.
    ///
    /// WebSocket status code 1010
    InsufficientExtensions,

    /// The server is terminating the connection because it encountered
    /// an unexpected condition that prevented it from fulfilling the request.
    ///
    /// WebSocket status code 1011
    ServerError,

    /// This status code is designated for use in
    /// applications expecting a status code to indicate that the
    /// connection was closed due to a failure to perform a TLS handshake.
    ///
    /// This status code may never be observed, as its purpose is fulfilled
    /// by the [`WebSocketError::TlsConnectionError`] error.
    ///
    /// # Oddities
    ///
    /// This status code is never sent by a peer, but is generated instead
    /// from the `websockets` library itself, as per spec, to indicate
    /// what's on the label.
    ///
    /// This status code can not be sent manually.
    ///
    /// WebSocket status code 1015
    TlsFailure,

    /// Status codes in the range `3000..=3999` are reserved for use by
    /// libraries, frameworks, and applications.  These status codes are
    /// registered directly with IANA.
    RegisteredStatus(u16),

    /// Status codes in the range `4000..=4999` are reserved for private use.
    PrivateStatus(u16),
}

impl TryFrom<u16> for Status {
    type Error = WebSocketError;

    fn try_from(value: u16) -> Result<Self, Self::Error> {
        match value {
            0..=999 => Err(WebSocketError::InvalidFrame(
                InvalidFrameReason::BadCloseCode,
            )),

            1000 => Ok(Self::Ok),
            1001 => Ok(Self::GoingAway),
            1002 => Ok(Self::ProtocolError),
            1003 => Ok(Self::UnacceptableData),
            // 1004 reserved
            1005 => Ok(Self::MissingStatusCode),
            1006 => Ok(Self::AbnormalShutdown),

            1007 => Ok(Self::InvalidData),
            1008 => Ok(Self::PolicyViolation),
            1009 => Ok(Self::MessageTooLarge),
            1010 => Ok(Self::InsufficientExtensions),
            1011 => Ok(Self::ServerError),

            1015 => Ok(Self::TlsFailure),

            3000..=3999 => Ok(Self::RegisteredStatus(value)),
            4000..=4999 => Ok(Self::PrivateStatus(value)),

            _ => Err(WebSocketError::InvalidFrame(
                InvalidFrameReason::BadCloseCode,
            )),
        }
    }
}
