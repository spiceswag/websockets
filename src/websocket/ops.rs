//! Operations on web sockets with custom future implementations.
//! This includes closing the websocket, and pinging the peer.

use futures::FutureExt;
use std::{
    convert::TryFrom,
    future::Future,
    pin::Pin,
    task::{Context, Poll},
};
use tokio::sync::oneshot;

use crate::{error::InvalidFrame, WebSocketError};

/// A futures that resolves as soon as a
/// pong message is received from the server.
///
/// Each pong future maps one-to-one with a ping frame sent
/// to the server, but not vice-versa, with respect to the ping sender.
///
/// The websocket spec states that servers peers may choose
/// to "aggregate" pong frames by only replying to the latest one.
/// Therefore, pong futures may resolve in waves,
/// which may produce a warped perception of the actual latency
/// between the websocket peers.
///
/// # Panics
///
/// Polling this future causes a panic if
/// the relevant websocket has been dropped or closed.
///
/// https://datatracker.ietf.org/doc/html/rfc6455#section-5.5.3
#[derive(Debug)]
pub struct Pong {
    pub(super) recv: oneshot::Receiver<PingPayload>,
}

impl Future for Pong {
    type Output = Option<PingPayload>;

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        self.recv.poll_unpin(cx).map(|res| res.ok())
    }
}

/// The contents of a `Ping`/`Pong` frame
///
/// https://datatracker.ietf.org/doc/html/rfc6455#section-5.5.3
#[derive(Debug)]
pub struct PingPayload {
    /// Optional application data contained in a `Ping`.
    pub payload: Option<Vec<u8>>,
}

/// How a WebSocket connection was closed.
#[derive(Debug, PartialEq, Eq)]
pub enum CloseOutcome {
    /// The WebSocket connection was closed normally.
    Normal(ClosePayload),
    /// The server took too long to reply with a `Close` frame,
    /// or took too long to shut down the TCP connection,
    /// so the client acted first.
    TimeOut,
}

impl CloseOutcome {
    /// Unwrap the outcome assuming it was a normal closure, or panic otherwise.
    ///
    /// # Panics
    ///
    /// This method panics if `self` is equal to [`CloseOutcome::TimeOut`]
    pub fn unwrap(self) -> ClosePayload {
        match self {
            Self::Normal(p) => p,
            Self::TimeOut => panic!("unwrap called on a time out close outcome"),
        }
    }
}

/// The body of a close frame, consisting of a status code
/// hinting at the reason why the connection is being closed,
/// and a reason message meant to be read by the developers of
/// the application communicating.
///
/// https://datatracker.ietf.org/doc/html/rfc6455#section-5.5.1
#[derive(Debug, PartialEq, Eq)]
pub struct ClosePayload {
    /// The closing status for this payload.
    pub status: Status,
    /// Reason given for closing the connection.
    pub reason: Option<String>,
}

/// Status codes observable during the closing of a WebSocket connection.
///
/// This enum has been idiot-proofed, for the lack of a better term.
///
/// That means you can not use this enum in combination with any other API of this crate
/// to cause an active WebSocket connection to enter an invalid state.
#[derive(Debug, PartialEq, Eq)]
pub enum Status {
    /// The purpose of the websocket has been fulfilled.
    ///
    /// WebSocket status code 1000
    Ok,

    /// An endpoint is leaving the connection,
    /// such as a browser navigating away or a web server shutting down.
    ///
    /// WebSocket status code 1001
    GoingAway,

    /// An endpoint is terminating the connection due to a protocol error.
    ///
    /// WebSocket status code 1002
    ProtocolError,

    /// An endpoint has received data of a type it doesn't understand.
    ///
    /// WebSocket status code 1003
    UnacceptableData,

    // 1004 reserved
    /// No actual status code is present.
    ///
    /// # Oddities
    ///
    /// This status code is never sent by a peer, but is generated instead
    /// from the `websockets` library itself, as per spec, to indicate
    /// what's on the label.
    ///
    /// This status code can not be sent manually.
    ///
    /// WebSocket status code 1005
    MissingStatusCode,

    /// Indicates that the connection was shut down abnormally,
    /// for example, if no `Close` frames were exchanged
    ///
    /// This status code may not be sent by a peer but instead,
    /// generated by the `websockets` library when the peer did not
    /// reply with a `Close` frame of their own during shutdown.
    ///
    /// This status code can not be sent manually.
    ///
    /// WebSocket status code 1006
    AbnormalShutdown,

    /// An endpoint received data that was inconsistent with the
    /// type of the message.
    ///
    /// WebSocket status code 1007
    InvalidData,

    /// An endpoint has received data within a message that violates its policy.
    ///
    /// WebSocket status code 1008
    PolicyViolation,

    /// An endpoint has received a message that was too big.
    ///
    /// WebSocket status code 1009
    MessageTooLarge,

    /// The client is terminating the connection because it
    /// expected the server to negotiate one or more extensions, but the server didn't.
    ///
    /// The list of extensions that are needed should appear in the `reason` part of the Close frame.
    ///
    /// WebSocket status code 1010
    InsufficientExtensions,

    /// The server is terminating the connection because it encountered
    /// an unexpected condition that prevented it from fulfilling the request.
    ///
    /// WebSocket status code 1011
    ServerError,

    /// This status code is designated for use in
    /// applications expecting a status code to indicate that the
    /// connection was closed due to a failure to perform a TLS handshake.
    ///
    /// This status code may never be observed, as its purpose is fulfilled
    /// by the [`WebSocketError::TlsConnectionError`] error.
    ///
    /// # Oddities
    ///
    /// This status code is never sent by a peer, but is generated instead
    /// from the `websockets` library itself, as per spec, to indicate
    /// what's on the label.
    ///
    /// This status code can not be sent manually.
    ///
    /// WebSocket status code 1015
    TlsFailure,

    /// Status codes in the range `3000..=3999` are reserved for use by
    /// libraries, frameworks, and applications.  These status codes are
    /// registered directly with IANA.
    RegisteredStatus(u16),

    /// Status codes in the range `4000..=4999` are reserved for private use.
    PrivateStatus(u16),
}

impl Status {
    /// If the status code can be sent through the WebSocket.
    pub fn sendable(&self) -> bool {
        match self {
            Self::MissingStatusCode => false,
            Self::AbnormalShutdown => false,
            Self::TlsFailure => false,
            _ => true,
        }
    }
}

impl TryFrom<u16> for Status {
    type Error = WebSocketError;

    fn try_from(value: u16) -> Result<Self, Self::Error> {
        match value {
            0..=999 => Err(WebSocketError::InvalidFrame(InvalidFrame::BadCloseCode)),

            1000 => Ok(Self::Ok),
            1001 => Ok(Self::GoingAway),
            1002 => Ok(Self::ProtocolError),
            1003 => Ok(Self::UnacceptableData),
            // 1004 reserved
            1005 => Ok(Self::MissingStatusCode),
            1006 => Ok(Self::AbnormalShutdown),

            1007 => Ok(Self::InvalidData),
            1008 => Ok(Self::PolicyViolation),
            1009 => Ok(Self::MessageTooLarge),
            1010 => Ok(Self::InsufficientExtensions),
            1011 => Ok(Self::ServerError),

            1015 => Ok(Self::TlsFailure),

            3000..=3999 => Ok(Self::RegisteredStatus(value)),
            4000..=4999 => Ok(Self::PrivateStatus(value)),

            _ => Err(WebSocketError::InvalidFrame(InvalidFrame::BadCloseCode)),
        }
    }
}

impl Into<u16> for Status {
    fn into(self) -> u16 {
        use Status::*;

        match self {
            Ok => 1000,
            GoingAway => 1001,
            ProtocolError => 1002,
            UnacceptableData => 1003,
            MissingStatusCode => 1005,
            AbnormalShutdown => 1006,
            InvalidData => 1007,
            PolicyViolation => 1008,
            MessageTooLarge => 1009,
            InsufficientExtensions => 1010,
            ServerError => 1011,
            TlsFailure => 1015,
            RegisteredStatus(v) => v,
            PrivateStatus(v) => v,
        }
    }
}
